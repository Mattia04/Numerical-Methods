{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"README","text":"<p>Warning</p> <p>This website is still work-in-progress, so any information could be wrong, partial or omitted.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>This website was created to give a guide on what to learn for physics  students interested in the field of programming for physics. Other students like mathematicians and engineers can also use this guide,  for some topics they are interested in.</p> <p>Note</p> <p>This guide assumes that you already have a basic experience in programming with <code>python</code> and <code>C++</code>.</p> Why <code>C++</code> and <code>python</code>? <p>I choose those two programming languages to write the guide because they are what I use, so I know them,  but they are also what the majority of physicists use.  </p> <p><code>C++</code> is fast, ideal for simulations and other computation-heavy tasks, (it is also object-oriented).</p> <p><code>python</code> is easy and has a lot of libraies, ideal for graphs, data analysis and other miscellaneous tasks.</p> <p>Obviously you are not forced to use those two, there are really good alternatives like: <code>C</code>, <code>julia</code>, <code>MATLAB</code> and <code>Fortran</code>. </p> <p>If you don't, you can follow some online tutorials, there a lot of them online for free, learn about:  data types, operations, input-output, conditionals, loops, functions and lambdas, scopes, basic data structures, standard library, and error handling.</p> <p>There is also a page dedicated to a brief review of some basic concepts see this page</p> <p>Do you want to start learning? see this page.</p>"},{"location":"#navigation-on-this-website","title":"Navigation on this website","text":"<p>At the end of each lesson there are two arrows to go to the next and previous page.</p> <p>You can also navigate thru the pages with the list on the left, and thru the section of the current page with the list on the right.</p> <p>Or you can even search for something using the search bar on the top.</p> <p>You can toggle light-dark mode using the icon on top, near the search bar.</p>"},{"location":"Best_Practices/","title":"Best Practices","text":"<p>Programming is not just writing code but there is also a huge world around it.</p>"},{"location":"Best_Practices/#must-do","title":"Must do","text":""},{"location":"Best_Practices/#reproducibility","title":"Reproducibility","text":""},{"location":"Best_Practices/#log-versions-and-library-versions","title":"Log versions and library versions.","text":"<p>Manage all the dependencies can be an hell if not done right. Using virtual environments like <code>venv</code> or <code>UV</code> or <code>conda</code> can help you manage all the dependencies and help with code reproducibility.</p>"},{"location":"Best_Practices/#use-version-control-and-collaborations","title":"Use Version Control and collaborations","text":"<p>With version control (<code>git</code>) you can roll back to a previous stable version if your code. It is good practice to always use version control even in solo projects. Also using <code>GitHub</code> or <code>GitLab</code> you can share your project and collaborate with others.</p>"},{"location":"Best_Practices/#configuration-files","title":"Configuration files","text":"<p>Use one of the following: <code>.json</code>, <code>.yaml</code>, <code>.toml</code> to make configuration files, containing the standard values of settings variables.</p>"},{"location":"Best_Practices/#documentation","title":"Documentation","text":"<p>Well-documented code is essential for reproducibility and collaboration. Add docstrings to functions and classes, with clear and coincise explanations, also consider adding code examples.</p>"},{"location":"Best_Practices/#readme","title":"README","text":"<p>Write a <code>README.md</code> (the <code>.md</code> extension is not obligatory, but it's the most common) file containing important information about the project like:  purpose, how to install and use, </p>"},{"location":"Best_Practices/#error-handling","title":"Error handling","text":"<p>The title is self-explanatory, you don't want to trow an error in your user face if they don't know your code base or, worse, if they don't even know how to program. So you should make sure your code properly handles all errors.</p>"},{"location":"Best_Practices/#validate-inputs","title":"Validate inputs","text":"<p>When you have to get an input validate as soon as possible if that input is correct. Do not trust the user! not even if the user is yourself. </p>"},{"location":"Best_Practices/#provide-helpful-error-messages","title":"Provide helpful error messages","text":"<p>When an input is not correct you have to make the user understand why the input is not working properly,  so write a short but complete error message containing all the information he needs to correct the input.</p>"},{"location":"Best_Practices/#should-do","title":"Should do","text":""},{"location":"Best_Practices/#project-structure","title":"Project Structure","text":"<p>Big projects usually have a well-defined file structure, and it's decided based on preferences, but when you are not given a project structure you should follow the following structure:</p> <pre><code>project_name/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 pyproject.toml            # Or requirements.txt + setup.py\n\u251c\u2500\u2500 Makefile                  # Optional: common tasks (run, clean, lint, etc.)\n\u251c\u2500\u2500 .gitignore                # List of ignored files and directories to NOT add on git\n\u251c\u2500\u2500 data/                     # Raw and processed data files (ignored if too large)\n\u2502   \u251c\u2500\u2500 raw/                  # Unmodified data\n\u2502   \u2514\u2500\u2500 processed/            # Cleaned and transformed data\n\u251c\u2500\u2500 notebooks/                # Jupyter notebooks for exploration, figures, etc.\n\u2502   \u2514\u2500\u2500 analysis.ipynb\n\u251c\u2500\u2500 docs/                     # Documentation (Markdown or Sphinx)\n\u2502   \u251c\u2500\u2500 index.md / index.rst\n\u2502   \u2514\u2500\u2500 api/\n\u251c\u2500\u2500 project_name/             # Main package directory (same name as project or \"src\")\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 config.py             # Global config and parameters\n\u2502   \u251c\u2500\u2500 main.py               # CLI entrypoint or main script\n\u2502   \u251c\u2500\u2500 core/                 # Core algorithms / numerical solvers\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 solver.py\n\u2502   \u251c\u2500\u2500 examples/             # Optional: Code examples\n\u2502   \u2502   \u2514\u2500\u2500 simple_example.py\n\u2502   \u2514\u2500\u2500 utils/                # Utility functions (I/O, plotting, etc.)\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 io.py\n\u2502       \u2514\u2500\u2500 plotting.py\n\u251c\u2500\u2500 tests/                    # Unit and integration tests\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 test_solver.py\n\u2502   \u2514\u2500\u2500 test_io.py\n\u251c\u2500\u2500 logs/                     # Logging output (can be added to .gitignore)\n\u2502   \u2514\u2500\u2500 run_2025_06_18.log\n\u251c\u2500\u2500 results/                  # Plots, figures, output data, etc.\n\u2502   \u251c\u2500\u2500 figs/\n\u2502   \u2514\u2500\u2500 tables/\n\u2514\u2500\u2500 scripts/                  # Bash or Python scripts for automation\n    \u251c\u2500\u2500 run_simulation.py\n    \u2514\u2500\u2500 clean_output.sh\n</code></pre> <p>A structure similar to this makes the project scalable.</p>"},{"location":"Best_Practices/#logging","title":"Logging","text":"<p>Use a logging module instead of printing everything to the console, also save the log files so you can check what went wrong.</p>"},{"location":"Best_Practices/#make-tests","title":"Make tests","text":"<p>Write test using <code>pytest</code> or <code>unittest</code> and validate them with analytical results. This makes sures your code does not have an unexpected behaviour. </p> <p>Note is best practice to test edge cases and stress conditions. </p> <p>You can also use CI pipelines to run automated tests.</p>"},{"location":"Best_Practices/#code-quality","title":"Code Quality","text":"<p>Write quality code by following the rules:</p> <ul> <li>Follow PEP8, to help with that you can use linters or formatters like <code>ruff</code> and <code>black</code>.</li> <li>Use typehints and then do type checks with <code>mypy</code> or other tools.</li> <li>Write modular code, with each function has a single aim. (This advice is to take with caution because not always writing modular code is the best choice, sometimes you don't want to write too many functions, it is up to you to choose which approach is better each time)</li> </ul>"},{"location":"Best_Practices/#other-tools","title":"Other Tools","text":""},{"location":"Best_Practices/#jupiter-notebooks","title":"Jupiter Notebooks","text":"<p>Use Jupiter Notebooks to write and test fast code, then when you asserted the correctness of the code you can go back to a python script (you can create a <code>.py</code> file from a notebook).</p>"},{"location":"Best_Practices/#profilers","title":"Profilers","text":"<p>If performance is important use profilers to understand what function calls take the majority of time and should be optimized.</p>"},{"location":"Best_Practices/#makefiles-automations","title":"Makefiles automations","text":"<p>Use makefiles or other scripts (like shell scripting or even other python scripts) to make automations like: downloading data, cleaning the project, resetting settings, updating the project, ecc..</p>"},{"location":"Best_Practices/#outputs","title":"Outputs","text":""},{"location":"Best_Practices/#save-outputs-as-standard-formats","title":"Save outputs as standard formats","text":"<p>If you don't have a specific constrain on your data output follow these rules:</p> <ul> <li>Use <code>.txt</code> or <code>.md</code> for texts.</li> <li>Use <code>.dat</code>, <code>.csv</code> or <code>.npy</code> for data tables.</li> <li>Use <code>.jpg</code>, <code>.png</code> or <code>.svg</code> for images.</li> <li>Use <code>.mp4</code> or <code>.gif</code> for videos and animations.</li> </ul>"},{"location":"Best_Practices/#add-metadata-to-outputs","title":"Add metadata to outputs","text":""},{"location":"Best_Practices/#use-checkpoints","title":"Use Checkpoints","text":"<p>For long simulations you should save your state to disk at time intervals (or when a certain condition occurs) like every hour. So if the program fails, after reading the logs to check when the error started, you can resume your program saving computational time.</p>"},{"location":"Best_Practices/#changelog","title":"Changelog","text":"<p>Maintain a changelog with updates for each version.</p>"},{"location":"Best_Practices/#write-short-usage-manuals-or-api-references","title":"Write short usage manuals or API references","text":"<p>If your program has to be used by other people consider writing a detailed reference to your code.</p>"},{"location":"Ex_Random_Numbers/","title":"Exercises on random numbers","text":""},{"location":"Ex_Random_Numbers/#1-sierpinski-triangle","title":"1. Sierpinski Triangle","text":"<p>There is a surprising way to generate an image of the Sieripinski triangle using random numbers.</p> <p>Generation</p> <p>Construct an equilateral triangle with labeled vertices, for example <code>1</code>, <code>2</code> and <code>3</code>.</p> <p>We start selecting a random point on the plane.</p> <p>Now we generate a random number between 1 and 3 (extremes included), and we draw a point in the middle point of the previous point and the vertex corrisponding to the random number generated. The new point generated would be used by the next iteration.</p> <p>We then repeat the process (<code>random number -&gt; draw midpoint -&gt; ...</code>) for a predefined large number of times like \\(N \\sim 10000\\) or more.</p> <p>Note</p> <p>Since we are going to increase the number of sides of our figure, making the code modular for the number of sides is a good idea.</p> Result <p>This is the result you will get</p> <p></p> Getting a better result <p>Since by starting on a random point would give us the first few points on noticiable \"wrong\" positions we can get a nicer result by skipping the first few points.</p> <p>One can also calculate the error \\(\\Delta\\) of the points from their actual position on the triangle after deleting the firsts \\(n\\) points using the formula: $$ \\Delta \\approx \\frac{\\ell}{2^n} $$ Where \\(\\ell\\) is the length of the triangle side. Note: this formula works only if the point is inside or near the triangle.</p> <p>We can notice that after the first \\(n = 10\\) iterations we have an error around 1000 times smaller, so we can decide to not draw the first 10 points and get a better result without compromising computational time (we loose only 10 points out of 10000 which is only 0.1% of the total points).</p> Making an animation <p>We could also make a simple animation by updating the plot frame after each point drawn.</p> <p>This is left as an excercise to the interested reader.</p> Example <p>Insert animation here</p>"},{"location":"Ex_Random_Numbers/#2-sierpinski-square","title":"2. Sierpinski Square","text":"<p>What happens when we increase the number of sides from 3 to 4 adding a fourth label to our random number generator, and we keep drawing the midpoint?</p> Filled Square? <p>By running the code you will notice that with this method we will get a filled square, which is not what we want.</p> <p>The fix is actually really simple can you think what we should change?</p> Tip 1 out of 2 <p>We want to get a hole in the middle, so we should change the distance from the previous point where we generate the new point. We want the new point to be located at 1/3 (from the vertex) of the segment connecting the random vertex from the previous point.</p> <p>Implementing this is easy, from taking the middle point, which is the average. We take the weighted average with weights: 2 on the vertex and 1 on the previous point.</p> <p>But this also does not gives us the result we attended, this gives us a cross in the middle but we want a hole.</p> Tip 2 out of 2 <p>To get a hole instead of a cross we would need to add 4 new generation points, each one located in the middle point of the square sides.</p> Result <p>Here is the correct result</p> <p></p>"},{"location":"Ex_Random_Numbers/#3-koch-snowflake","title":"3. Koch Snowflake","text":"<p>Let's try making something similar, but different.</p> <p>Take an exagon, with labeled vertices, and the wighted average for generating the new point (with weights: 2 on the vertex and 1 on the previous point). With this rules you will get a different structure called the Koch Snowflake.</p> Result <p>Here is the correct result</p> <p></p>"},{"location":"Ex_Random_Numbers/#4-changing-the-number-of-dimensions","title":"4. Changing the number of dimensions.","text":"<p>What happens when we just generate points on one line? We get the Cantor Set.</p> <p>Note</p> <p>When we first generated the Sierpinski Square in \"Tip 1 out of 2\", we generated the two dimensional Cantor Set.</p>"},{"location":"Ex_Random_Numbers/#41-cantor-set","title":"4.1. Cantor Set","text":"<p>To generate the cantor set we just need 2 points and the weighted average at 2 to 1 weights like before.</p> Result <p></p> <p>Note</p> <p>When generating this image we needed to add one dimension to make the graph to make it visualizable, so we can simply add a random y-axis position for each point.</p> <p>We went down in dimensions can we go up? Yes, but the number of points we need to generate will increase a lot (\\(N\\sim 10^6\\)).</p>"},{"location":"Ex_Random_Numbers/#42-tetrahedron","title":"4.2. Tetrahedron","text":"Result <p>Note</p> <p>You will not get a good result as the one shown in the image using just python.  I wanted to add this and the following two excercies to show you that we can also make some \"science art\" if we want to. The object in the images have been generated with a python script and then they have been rendered in blender.</p>"},{"location":"Ex_Random_Numbers/#43-cube","title":"4.3. Cube","text":"Result"},{"location":"Ex_Random_Numbers/#44-dodecahedron","title":"4.4. Dodecahedron","text":"Result <p>The page is finished, but you can keep on trying making different shapes and fractals if you want!</p>"},{"location":"Ex_Random_Numbers/#5-a-more-efficient-way-of-doing-all-of-this","title":"5. A more Efficient Way of doing all of this","text":"<p>Affine Iterated Function System (IFS)</p>"},{"location":"Ex_Random_Numbers/#51-dodecahedron-with-more-resolution","title":"5.1. Dodecahedron with more resolution","text":""},{"location":"Ex_Random_Numbers/#52-generating-leafs-and-trees","title":"5.2. Generating leafs and trees","text":""}]}